import { C as Comments, P as PluginHandler, a as Plugin, I as ImportExportItemObject, t as tsNodeToString, S as StringCase, U as UserConfig, b as Client, c as IR } from './types.d-BzJA3GSb.cjs';
export { j as Client, D as DefinePlugin, E as ExpressionTransformer, L as LegacyIR, O as OpenApi, d as OpenApiMetaObject, e as OpenApiOperationObject, f as OpenApiParameterObject, g as OpenApiRequestBodyObject, h as OpenApiResponseObject, i as OpenApiSchemaObject, T as TypeTransformer } from './types.d-BzJA3GSb.cjs';
import * as typescript from 'typescript';
import typescript__default from 'typescript';
import 'semver';
import 'node:fs';

type AccessLevel = 'private' | 'protected' | 'public';
type FunctionParameter = {
    accessLevel?: AccessLevel;
    default?: any;
    isReadOnly?: boolean;
    isRequired?: boolean;
    name: string;
    type?: any | typescript__default.TypeNode;
} | {
    destructure: ReadonlyArray<FunctionParameter>;
    type?: any | typescript__default.TypeNode;
};
interface FunctionTypeParameter {
    default?: any;
    extends?: string | typescript__default.TypeNode;
    name: string | typescript__default.Identifier;
}
type SyntaxKindKeyword = 'any' | 'async' | 'boolean' | 'export' | 'never' | 'number' | 'private' | 'protected' | 'public' | 'readonly' | 'static' | 'string' | 'undefined' | 'unknown' | 'void';
type ObjectValue = {
    assertion?: 'any' | typescript__default.TypeNode;
    comments?: Comments;
    spread: string;
} | {
    comments?: Comments;
    isValueAccess?: boolean;
    key: string;
    shorthand?: boolean;
    value: any;
};

declare const defaultPaginationKeywords: readonly ["after", "before", "cursor", "offset", "page", "start"];

/**
 * Default plugins used to generate artifacts if plugins aren't specified.
 */
declare const defaultPlugins: readonly ["@hey-api/typescript", "@hey-api/sdk"];

declare const clientDefaultConfig: {
    readonly baseUrl: true;
    readonly bundle: true;
    readonly exportFromIndex: false;
};
declare const clientDefaultMeta: {
    readonly dependencies: readonly ["@hey-api/typescript"];
    readonly output: "client";
    readonly tags: readonly ["client"];
};

declare const clientPluginHandler: ({ plugin, }: Parameters<PluginHandler>[0]) => void;

declare const definePluginConfig: <T extends Plugin.Types>(defaultConfig: Plugin.Config<T>) => (userConfig?: Omit<Plugin.UserConfig<T["config"]>, "name">) => Omit<Plugin.Config<T>, "name"> & {
    /**
     * Cast name to `any` so it doesn't throw type error in `plugins` array.
     * We could allow any `string` as plugin `name` in the object syntax, but
     * that TypeScript trick would cause all string methods to appear as
     * suggested auto completions, which is undesirable.
     */
    name: any;
};

type ImportExportItem = ImportExportItemObject | string;

type Property = {
    comment?: Comments;
    isReadOnly?: boolean;
    isRequired?: boolean;
    name: string | typescript__default.PropertyName;
    type: any | typescript__default.TypeNode;
};

declare const tsc: {
    anonymousFunction: ({ async, comment, multiLine, parameters, returnType, statements, types, }: {
        async?: boolean;
        comment?: Comments;
        multiLine?: boolean;
        parameters?: FunctionParameter[];
        returnType?: string | typescript.TypeNode;
        statements?: ReadonlyArray<typescript.Statement>;
        types?: FunctionTypeParameter[];
    }) => typescript.FunctionExpression;
    arrayLiteralExpression: <T>({ elements, multiLine, }: {
        elements: T[];
        multiLine?: boolean;
    }) => typescript.ArrayLiteralExpression;
    arrowFunction: ({ async, comment, multiLine, parameters, returnType, statements, types, }: {
        async?: boolean;
        comment?: Comments;
        multiLine?: boolean;
        parameters?: ReadonlyArray<FunctionParameter>;
        returnType?: string | typescript.TypeNode;
        statements?: typescript.Statement[] | typescript.Expression;
        types?: FunctionTypeParameter[];
    }) => typescript.ArrowFunction;
    asExpression: ({ expression, type, }: {
        expression: typescript.Expression;
        type: typescript.TypeNode;
    }) => typescript.AsExpression;
    assignment: ({ left, right, }: {
        left: typescript.Expression;
        right: typescript.Expression;
    }) => typescript.AssignmentExpression<typescript.EqualsToken>;
    awaitExpression: ({ expression, }: {
        expression: typescript.Expression;
    }) => typescript.AwaitExpression;
    binaryExpression: ({ left, operator, right, }: {
        left: typescript.Expression;
        operator?: "=" | "===" | "in" | "??";
        right: typescript.Expression | string;
    }) => typescript.BinaryExpression;
    block: ({ multiLine, statements, }: {
        multiLine?: boolean;
        statements: ReadonlyArray<typescript.Statement>;
    }) => typescript.Block;
    callExpression: ({ functionName, parameters, types, }: {
        functionName: string | typescript.PropertyAccessExpression | typescript.PropertyAccessChain | typescript.ElementAccessExpression | typescript.Expression;
        parameters?: Array<string | typescript.Expression | undefined>;
        types?: ReadonlyArray<typescript.TypeNode>;
    }) => typescript.CallExpression;
    classDeclaration: ({ decorator, exportClass, extendedClasses, name, nodes, }: {
        decorator?: {
            args: any[];
            name: string;
        };
        exportClass?: boolean;
        extendedClasses?: ReadonlyArray<string>;
        name: string;
        nodes: ReadonlyArray<typescript.ClassElement>;
    }) => typescript.ClassDeclaration;
    conditionalExpression: ({ condition, whenFalse, whenTrue, }: {
        condition: typescript.Expression;
        whenFalse: typescript.Expression;
        whenTrue: typescript.Expression;
    }) => typescript.ConditionalExpression;
    constVariable: ({ assertion, comment, destructure, exportConst, expression, name, typeName, }: {
        assertion?: "const" | typescript.TypeNode;
        comment?: Comments;
        destructure?: boolean;
        exportConst?: boolean;
        expression: typescript.Expression;
        name: string | typescript.TypeReferenceNode;
        typeName?: string | typescript.IndexedAccessTypeNode | typescript.TypeNode;
    }) => typescript.VariableStatement;
    constructorDeclaration: ({ accessLevel, comment, multiLine, parameters, statements, }: {
        accessLevel?: AccessLevel;
        comment?: Comments;
        multiLine?: boolean;
        parameters?: FunctionParameter[];
        statements?: typescript.Statement[];
    }) => typescript.ConstructorDeclaration;
    enumDeclaration: <T extends Record<string, any> | Array<ObjectValue>>({ comments: enumMemberComments, leadingComment: comments, name, obj, }: {
        comments?: Record<string | number, Comments>;
        leadingComment?: Comments;
        name: string | typescript.TypeReferenceNode;
        obj: T;
    }) => typescript.EnumDeclaration;
    exportAllDeclaration: ({ module, }: {
        module: string;
    }) => typescript.ExportDeclaration;
    exportNamedDeclaration: ({ exports, module, }: {
        exports: Array<ImportExportItem> | ImportExportItem;
        module: string;
    }) => typescript.ExportDeclaration;
    expressionToStatement: ({ expression, }: {
        expression: typescript.Expression;
    }) => typescript.ExpressionStatement;
    forOfStatement: ({ awaitModifier, expression, initializer, statement, }: {
        awaitModifier?: typescript.AwaitKeyword;
        expression: typescript.Expression;
        initializer: typescript.ForInitializer;
        statement: typescript.Statement;
    }) => typescript.ForOfStatement;
    functionTypeNode: ({ parameters, returnType, typeParameters, }: {
        parameters?: typescript.ParameterDeclaration[];
        returnType: typescript.TypeNode;
        typeParameters?: typescript.TypeParameterDeclaration[];
    }) => typescript.FunctionTypeNode;
    getAccessorDeclaration: ({ name, returnType, statements, }: {
        name: string | typescript.PropertyName;
        returnType?: string | typescript.Identifier;
        statements: ReadonlyArray<typescript.Statement>;
    }) => typescript.GetAccessorDeclaration;
    identifier: ({ text }: {
        text: string;
    }) => typescript.Identifier;
    ifStatement: ({ elseStatement, expression, thenStatement, }: {
        elseStatement?: typescript.Statement;
        expression: typescript.Expression;
        thenStatement: typescript.Statement;
    }) => typescript.IfStatement;
    indexedAccessTypeNode: ({ indexType, objectType, }: {
        indexType: typescript.TypeNode;
        objectType: typescript.TypeNode;
    }) => typescript.IndexedAccessTypeNode;
    isTsNode: (node: any) => node is typescript.Expression;
    keywordTypeNode: ({ keyword, }: {
        keyword: Extract<SyntaxKindKeyword, "any" | "boolean" | "never" | "number" | "string" | "undefined" | "unknown" | "void">;
    }) => typescript.KeywordTypeNode<typescript.SyntaxKind.VoidKeyword | typescript.SyntaxKind.AnyKeyword | typescript.SyntaxKind.BooleanKeyword | typescript.SyntaxKind.NeverKeyword | typescript.SyntaxKind.NumberKeyword | typescript.SyntaxKind.StringKeyword | typescript.SyntaxKind.UndefinedKeyword | typescript.SyntaxKind.UnknownKeyword>;
    literalTypeNode: ({ literal, }: {
        literal: typescript.LiteralTypeNode["literal"];
    }) => typescript.LiteralTypeNode;
    mappedTypeNode: ({ members, nameType, questionToken, readonlyToken, type, typeParameter, }: {
        members?: typescript.NodeArray<typescript.TypeElement>;
        nameType?: typescript.TypeNode;
        questionToken?: typescript.QuestionToken | typescript.PlusToken | typescript.MinusToken;
        readonlyToken?: typescript.ReadonlyKeyword | typescript.PlusToken | typescript.MinusToken;
        type?: typescript.TypeNode;
        typeParameter: typescript.TypeParameterDeclaration;
    }) => typescript.MappedTypeNode;
    methodDeclaration: ({ accessLevel, comment, isStatic, multiLine, name, parameters, returnType, statements, types, }: {
        accessLevel?: AccessLevel;
        comment?: Comments;
        isStatic?: boolean;
        multiLine?: boolean;
        name: string;
        parameters?: ReadonlyArray<FunctionParameter>;
        returnType?: string | typescript.TypeNode;
        statements?: typescript.Statement[];
        types?: FunctionTypeParameter[];
    }) => typescript.MethodDeclaration;
    namedImportDeclarations: ({ imports, module, }: {
        imports: Array<ImportExportItem> | ImportExportItem;
        module: string;
    }) => typescript.ImportDeclaration;
    namespaceDeclaration: ({ name, statements, }: {
        name: string;
        statements: Array<typescript.Statement>;
    }) => typescript.ModuleDeclaration;
    newExpression: ({ argumentsArray, expression, typeArguments, }: {
        argumentsArray?: Array<typescript.Expression>;
        expression: typescript.Expression;
        typeArguments?: Array<typescript.TypeNode>;
    }) => typescript.NewExpression;
    nodeToString: typeof tsNodeToString;
    null: () => typescript.NullLiteral;
    objectExpression: <T extends Record<string, any> | Array<ObjectValue>>({ comments, identifiers, multiLine, obj, shorthand, unescape, }: {
        comments?: Comments;
        identifiers?: string[];
        multiLine?: boolean;
        obj: T;
        shorthand?: boolean;
        unescape?: boolean;
    }) => typescript.ObjectLiteralExpression;
    ots: {
        boolean: (value: boolean) => typescript.TrueLiteral | typescript.FalseLiteral;
        export: ({ alias, asType, name }: ImportExportItemObject) => typescript.ExportSpecifier;
        import: ({ alias, asType, name }: ImportExportItemObject) => typescript.ImportSpecifier;
        number: (value: number) => typescript.NumericLiteral | typescript.PrefixUnaryExpression;
        string: (value: string, unescape?: boolean) => typescript.Identifier | typescript.StringLiteral;
    };
    parameterDeclaration: ({ initializer, modifiers, name, required, type, }: {
        initializer?: typescript.Expression;
        modifiers?: ReadonlyArray<typescript.ModifierLike>;
        name: string | typescript.BindingName;
        required?: boolean;
        type?: typescript.TypeNode;
    }) => typescript.ParameterDeclaration;
    propertyAccessExpression: ({ expression, isOptional, name, }: {
        expression: string | typescript.Expression;
        isOptional?: boolean;
        name: string | number | typescript.MemberName;
    }) => typescript.PropertyAccessChain | typescript.PropertyAccessExpression | typescript.ElementAccessExpression;
    propertyAccessExpressions: ({ expressions, }: {
        expressions: Array<string | typescript.Expression | typescript.MemberName>;
    }) => typescript.PropertyAccessExpression;
    propertyAssignment: ({ initializer, name, }: {
        initializer: typescript.Expression;
        name: string | typescript.PropertyName;
    }) => typescript.PropertyAssignment;
    propertyDeclaration: ({ initializer, modifier, name, type, }: {
        initializer?: typescript.Expression;
        modifier?: AccessLevel | "async" | "export" | "readonly" | "static";
        name: string | typescript.PropertyName;
        type?: typescript.TypeNode;
    }) => typescript.PropertyDeclaration;
    regularExpressionLiteral: ({ flags, text, }: {
        flags?: ReadonlyArray<"g" | "i" | "m" | "s" | "u" | "y">;
        text: string;
    }) => typescript.RegularExpressionLiteral;
    returnFunctionCall: ({ args, name, types, }: {
        args: any[];
        name: string | typescript.Expression;
        types?: ReadonlyArray<string | typescript.StringLiteral>;
    }) => typescript.ReturnStatement;
    returnStatement: ({ expression, }: {
        expression?: typescript.Expression;
    }) => typescript.ReturnStatement;
    returnVariable: ({ expression, }: {
        expression: string | typescript.Expression;
    }) => typescript.ReturnStatement;
    safeAccessExpression: (path: string[]) => typescript.Expression;
    stringLiteral: ({ isSingleQuote, text, }: {
        isSingleQuote?: boolean;
        text: string;
    }) => typescript.StringLiteral;
    templateLiteralType: ({ value, }: {
        value: ReadonlyArray<string | typescript.TypeNode>;
    }) => typescript.TemplateLiteralTypeNode;
    this: () => typescript.ThisExpression;
    transformArrayMap: ({ path, transformExpression, }: {
        path: string[];
        transformExpression: typescript.Expression;
    }) => typescript.IfStatement;
    transformArrayMutation: ({ path, transformerName, }: {
        path: string[];
        transformerName: string;
    }) => typescript.Statement;
    transformDateMutation: ({ path, }: {
        path: string[];
    }) => typescript.Statement;
    transformFunctionMutation: ({ path, transformerName, }: {
        path: string[];
        transformerName: string;
    }) => typescript.IfStatement[];
    transformNewDate: ({ parameterName, }: {
        parameterName: string;
    }) => typescript.NewExpression;
    typeAliasDeclaration: ({ comment, exportType, name, type, typeParameters, }: {
        comment?: Comments;
        exportType?: boolean;
        name: string | typescript.TypeReferenceNode;
        type: string | typescript.TypeNode | typescript.Identifier;
        typeParameters?: FunctionTypeParameter[];
    }) => typescript.TypeAliasDeclaration;
    typeArrayNode: (types: ReadonlyArray<any | typescript.TypeNode> | typescript.TypeNode | typescript.Identifier | string, isNullable?: boolean) => typescript.TypeNode;
    typeInterfaceNode: ({ indexKey, indexProperty, isNullable, properties, useLegacyResolution, }: {
        indexKey?: typescript.TypeReferenceNode;
        indexProperty?: Property;
        isNullable?: boolean;
        properties: Property[];
        useLegacyResolution: boolean;
    }) => typescript.TypeNode;
    typeIntersectionNode: ({ isNullable, types, }: {
        isNullable?: boolean;
        types: (any | typescript.TypeNode)[];
    }) => typescript.TypeNode;
    typeNode: (base: any | typescript.TypeNode, args?: (any | typescript.TypeNode)[]) => typescript.TypeNode;
    typeOfExpression: ({ text, }: {
        text: string | typescript.Identifier;
    }) => typescript.TypeOfExpression;
    typeOperatorNode: ({ operator, type, }: {
        operator: "keyof" | "readonly" | "unique";
        type: typescript.TypeNode;
    }) => typescript.TypeOperatorNode;
    typeParameterDeclaration: ({ constraint, defaultType, modifiers, name, }: {
        constraint?: typescript.TypeNode;
        defaultType?: typescript.TypeNode;
        modifiers?: Array<typescript.Modifier>;
        name: string | typescript.Identifier;
    }) => typescript.TypeParameterDeclaration;
    typeParenthesizedNode: ({ type }: {
        type: typescript.TypeNode;
    }) => typescript.ParenthesizedTypeNode;
    typeRecordNode: (keys: (any | typescript.TypeNode)[], values: (any | typescript.TypeNode)[], isNullable?: boolean, useLegacyResolution?: boolean) => typescript.TypeNode;
    typeReferenceNode: ({ typeArguments, typeName, }: {
        typeArguments?: typescript.TypeNode[];
        typeName: string | typescript.EntityName;
    }) => typescript.TypeReferenceNode;
    typeTupleNode: ({ isNullable, types, }: {
        isNullable?: boolean;
        types: Array<any | typescript.TypeNode>;
    }) => typescript.TypeNode;
    typeUnionNode: ({ isNullable, types, }: {
        isNullable?: boolean;
        types: ReadonlyArray<any | typescript.TypeNode>;
    }) => typescript.TypeNode;
    valueToExpression: <T = unknown>({ identifiers, isValueAccess, shorthand, unescape, value, }: {
        identifiers?: string[];
        isValueAccess?: boolean;
        shorthand?: boolean;
        unescape?: boolean;
        value: T;
    }) => typescript.Expression | undefined;
};
/** @deprecated use tsc */
declare const compiler: {
    anonymousFunction: ({ async, comment, multiLine, parameters, returnType, statements, types, }: {
        async?: boolean;
        comment?: Comments;
        multiLine?: boolean;
        parameters?: FunctionParameter[];
        returnType?: string | typescript.TypeNode;
        statements?: ReadonlyArray<typescript.Statement>;
        types?: FunctionTypeParameter[];
    }) => typescript.FunctionExpression;
    arrayLiteralExpression: <T>({ elements, multiLine, }: {
        elements: T[];
        multiLine?: boolean;
    }) => typescript.ArrayLiteralExpression;
    arrowFunction: ({ async, comment, multiLine, parameters, returnType, statements, types, }: {
        async?: boolean;
        comment?: Comments;
        multiLine?: boolean;
        parameters?: ReadonlyArray<FunctionParameter>;
        returnType?: string | typescript.TypeNode;
        statements?: typescript.Statement[] | typescript.Expression;
        types?: FunctionTypeParameter[];
    }) => typescript.ArrowFunction;
    asExpression: ({ expression, type, }: {
        expression: typescript.Expression;
        type: typescript.TypeNode;
    }) => typescript.AsExpression;
    assignment: ({ left, right, }: {
        left: typescript.Expression;
        right: typescript.Expression;
    }) => typescript.AssignmentExpression<typescript.EqualsToken>;
    awaitExpression: ({ expression, }: {
        expression: typescript.Expression;
    }) => typescript.AwaitExpression;
    binaryExpression: ({ left, operator, right, }: {
        left: typescript.Expression;
        operator?: "=" | "===" | "in" | "??";
        right: typescript.Expression | string;
    }) => typescript.BinaryExpression;
    block: ({ multiLine, statements, }: {
        multiLine?: boolean;
        statements: ReadonlyArray<typescript.Statement>;
    }) => typescript.Block;
    callExpression: ({ functionName, parameters, types, }: {
        functionName: string | typescript.PropertyAccessExpression | typescript.PropertyAccessChain | typescript.ElementAccessExpression | typescript.Expression;
        parameters?: Array<string | typescript.Expression | undefined>;
        types?: ReadonlyArray<typescript.TypeNode>;
    }) => typescript.CallExpression;
    classDeclaration: ({ decorator, exportClass, extendedClasses, name, nodes, }: {
        decorator?: {
            args: any[];
            name: string;
        };
        exportClass?: boolean;
        extendedClasses?: ReadonlyArray<string>;
        name: string;
        nodes: ReadonlyArray<typescript.ClassElement>;
    }) => typescript.ClassDeclaration;
    conditionalExpression: ({ condition, whenFalse, whenTrue, }: {
        condition: typescript.Expression;
        whenFalse: typescript.Expression;
        whenTrue: typescript.Expression;
    }) => typescript.ConditionalExpression;
    constVariable: ({ assertion, comment, destructure, exportConst, expression, name, typeName, }: {
        assertion?: "const" | typescript.TypeNode;
        comment?: Comments;
        destructure?: boolean;
        exportConst?: boolean;
        expression: typescript.Expression;
        name: string | typescript.TypeReferenceNode;
        typeName?: string | typescript.IndexedAccessTypeNode | typescript.TypeNode;
    }) => typescript.VariableStatement;
    constructorDeclaration: ({ accessLevel, comment, multiLine, parameters, statements, }: {
        accessLevel?: AccessLevel;
        comment?: Comments;
        multiLine?: boolean;
        parameters?: FunctionParameter[];
        statements?: typescript.Statement[];
    }) => typescript.ConstructorDeclaration;
    enumDeclaration: <T extends Record<string, any> | Array<ObjectValue>>({ comments: enumMemberComments, leadingComment: comments, name, obj, }: {
        comments?: Record<string | number, Comments>;
        leadingComment?: Comments;
        name: string | typescript.TypeReferenceNode;
        obj: T;
    }) => typescript.EnumDeclaration;
    exportAllDeclaration: ({ module, }: {
        module: string;
    }) => typescript.ExportDeclaration;
    exportNamedDeclaration: ({ exports, module, }: {
        exports: Array<ImportExportItem> | ImportExportItem;
        module: string;
    }) => typescript.ExportDeclaration;
    expressionToStatement: ({ expression, }: {
        expression: typescript.Expression;
    }) => typescript.ExpressionStatement;
    forOfStatement: ({ awaitModifier, expression, initializer, statement, }: {
        awaitModifier?: typescript.AwaitKeyword;
        expression: typescript.Expression;
        initializer: typescript.ForInitializer;
        statement: typescript.Statement;
    }) => typescript.ForOfStatement;
    functionTypeNode: ({ parameters, returnType, typeParameters, }: {
        parameters?: typescript.ParameterDeclaration[];
        returnType: typescript.TypeNode;
        typeParameters?: typescript.TypeParameterDeclaration[];
    }) => typescript.FunctionTypeNode;
    getAccessorDeclaration: ({ name, returnType, statements, }: {
        name: string | typescript.PropertyName;
        returnType?: string | typescript.Identifier;
        statements: ReadonlyArray<typescript.Statement>;
    }) => typescript.GetAccessorDeclaration;
    identifier: ({ text }: {
        text: string;
    }) => typescript.Identifier;
    ifStatement: ({ elseStatement, expression, thenStatement, }: {
        elseStatement?: typescript.Statement;
        expression: typescript.Expression;
        thenStatement: typescript.Statement;
    }) => typescript.IfStatement;
    indexedAccessTypeNode: ({ indexType, objectType, }: {
        indexType: typescript.TypeNode;
        objectType: typescript.TypeNode;
    }) => typescript.IndexedAccessTypeNode;
    isTsNode: (node: any) => node is typescript.Expression;
    keywordTypeNode: ({ keyword, }: {
        keyword: Extract<SyntaxKindKeyword, "any" | "boolean" | "never" | "number" | "string" | "undefined" | "unknown" | "void">;
    }) => typescript.KeywordTypeNode<typescript.SyntaxKind.VoidKeyword | typescript.SyntaxKind.AnyKeyword | typescript.SyntaxKind.BooleanKeyword | typescript.SyntaxKind.NeverKeyword | typescript.SyntaxKind.NumberKeyword | typescript.SyntaxKind.StringKeyword | typescript.SyntaxKind.UndefinedKeyword | typescript.SyntaxKind.UnknownKeyword>;
    literalTypeNode: ({ literal, }: {
        literal: typescript.LiteralTypeNode["literal"];
    }) => typescript.LiteralTypeNode;
    mappedTypeNode: ({ members, nameType, questionToken, readonlyToken, type, typeParameter, }: {
        members?: typescript.NodeArray<typescript.TypeElement>;
        nameType?: typescript.TypeNode;
        questionToken?: typescript.QuestionToken | typescript.PlusToken | typescript.MinusToken;
        readonlyToken?: typescript.ReadonlyKeyword | typescript.PlusToken | typescript.MinusToken;
        type?: typescript.TypeNode;
        typeParameter: typescript.TypeParameterDeclaration;
    }) => typescript.MappedTypeNode;
    methodDeclaration: ({ accessLevel, comment, isStatic, multiLine, name, parameters, returnType, statements, types, }: {
        accessLevel?: AccessLevel;
        comment?: Comments;
        isStatic?: boolean;
        multiLine?: boolean;
        name: string;
        parameters?: ReadonlyArray<FunctionParameter>;
        returnType?: string | typescript.TypeNode;
        statements?: typescript.Statement[];
        types?: FunctionTypeParameter[];
    }) => typescript.MethodDeclaration;
    namedImportDeclarations: ({ imports, module, }: {
        imports: Array<ImportExportItem> | ImportExportItem;
        module: string;
    }) => typescript.ImportDeclaration;
    namespaceDeclaration: ({ name, statements, }: {
        name: string;
        statements: Array<typescript.Statement>;
    }) => typescript.ModuleDeclaration;
    newExpression: ({ argumentsArray, expression, typeArguments, }: {
        argumentsArray?: Array<typescript.Expression>;
        expression: typescript.Expression;
        typeArguments?: Array<typescript.TypeNode>;
    }) => typescript.NewExpression;
    nodeToString: typeof tsNodeToString;
    null: () => typescript.NullLiteral;
    objectExpression: <T extends Record<string, any> | Array<ObjectValue>>({ comments, identifiers, multiLine, obj, shorthand, unescape, }: {
        comments?: Comments;
        identifiers?: string[];
        multiLine?: boolean;
        obj: T;
        shorthand?: boolean;
        unescape?: boolean;
    }) => typescript.ObjectLiteralExpression;
    ots: {
        boolean: (value: boolean) => typescript.TrueLiteral | typescript.FalseLiteral;
        export: ({ alias, asType, name }: ImportExportItemObject) => typescript.ExportSpecifier;
        import: ({ alias, asType, name }: ImportExportItemObject) => typescript.ImportSpecifier;
        number: (value: number) => typescript.NumericLiteral | typescript.PrefixUnaryExpression;
        string: (value: string, unescape?: boolean) => typescript.Identifier | typescript.StringLiteral;
    };
    parameterDeclaration: ({ initializer, modifiers, name, required, type, }: {
        initializer?: typescript.Expression;
        modifiers?: ReadonlyArray<typescript.ModifierLike>;
        name: string | typescript.BindingName;
        required?: boolean;
        type?: typescript.TypeNode;
    }) => typescript.ParameterDeclaration;
    propertyAccessExpression: ({ expression, isOptional, name, }: {
        expression: string | typescript.Expression;
        isOptional?: boolean;
        name: string | number | typescript.MemberName;
    }) => typescript.PropertyAccessChain | typescript.PropertyAccessExpression | typescript.ElementAccessExpression;
    propertyAccessExpressions: ({ expressions, }: {
        expressions: Array<string | typescript.Expression | typescript.MemberName>;
    }) => typescript.PropertyAccessExpression;
    propertyAssignment: ({ initializer, name, }: {
        initializer: typescript.Expression;
        name: string | typescript.PropertyName;
    }) => typescript.PropertyAssignment;
    propertyDeclaration: ({ initializer, modifier, name, type, }: {
        initializer?: typescript.Expression;
        modifier?: AccessLevel | "async" | "export" | "readonly" | "static";
        name: string | typescript.PropertyName;
        type?: typescript.TypeNode;
    }) => typescript.PropertyDeclaration;
    regularExpressionLiteral: ({ flags, text, }: {
        flags?: ReadonlyArray<"g" | "i" | "m" | "s" | "u" | "y">;
        text: string;
    }) => typescript.RegularExpressionLiteral;
    returnFunctionCall: ({ args, name, types, }: {
        args: any[];
        name: string | typescript.Expression;
        types?: ReadonlyArray<string | typescript.StringLiteral>;
    }) => typescript.ReturnStatement;
    returnStatement: ({ expression, }: {
        expression?: typescript.Expression;
    }) => typescript.ReturnStatement;
    returnVariable: ({ expression, }: {
        expression: string | typescript.Expression;
    }) => typescript.ReturnStatement;
    safeAccessExpression: (path: string[]) => typescript.Expression;
    stringLiteral: ({ isSingleQuote, text, }: {
        isSingleQuote?: boolean;
        text: string;
    }) => typescript.StringLiteral;
    templateLiteralType: ({ value, }: {
        value: ReadonlyArray<string | typescript.TypeNode>;
    }) => typescript.TemplateLiteralTypeNode;
    this: () => typescript.ThisExpression;
    transformArrayMap: ({ path, transformExpression, }: {
        path: string[];
        transformExpression: typescript.Expression;
    }) => typescript.IfStatement;
    transformArrayMutation: ({ path, transformerName, }: {
        path: string[];
        transformerName: string;
    }) => typescript.Statement;
    transformDateMutation: ({ path, }: {
        path: string[];
    }) => typescript.Statement;
    transformFunctionMutation: ({ path, transformerName, }: {
        path: string[];
        transformerName: string;
    }) => typescript.IfStatement[];
    transformNewDate: ({ parameterName, }: {
        parameterName: string;
    }) => typescript.NewExpression;
    typeAliasDeclaration: ({ comment, exportType, name, type, typeParameters, }: {
        comment?: Comments;
        exportType?: boolean;
        name: string | typescript.TypeReferenceNode;
        type: string | typescript.TypeNode | typescript.Identifier;
        typeParameters?: FunctionTypeParameter[];
    }) => typescript.TypeAliasDeclaration;
    typeArrayNode: (types: ReadonlyArray<any | typescript.TypeNode> | typescript.TypeNode | typescript.Identifier | string, isNullable?: boolean) => typescript.TypeNode;
    typeInterfaceNode: ({ indexKey, indexProperty, isNullable, properties, useLegacyResolution, }: {
        indexKey?: typescript.TypeReferenceNode;
        indexProperty?: Property;
        isNullable?: boolean;
        properties: Property[];
        useLegacyResolution: boolean;
    }) => typescript.TypeNode;
    typeIntersectionNode: ({ isNullable, types, }: {
        isNullable?: boolean;
        types: (any | typescript.TypeNode)[];
    }) => typescript.TypeNode;
    typeNode: (base: any | typescript.TypeNode, args?: (any | typescript.TypeNode)[]) => typescript.TypeNode;
    typeOfExpression: ({ text, }: {
        text: string | typescript.Identifier;
    }) => typescript.TypeOfExpression;
    typeOperatorNode: ({ operator, type, }: {
        operator: "keyof" | "readonly" | "unique";
        type: typescript.TypeNode;
    }) => typescript.TypeOperatorNode;
    typeParameterDeclaration: ({ constraint, defaultType, modifiers, name, }: {
        constraint?: typescript.TypeNode;
        defaultType?: typescript.TypeNode;
        modifiers?: Array<typescript.Modifier>;
        name: string | typescript.Identifier;
    }) => typescript.TypeParameterDeclaration;
    typeParenthesizedNode: ({ type }: {
        type: typescript.TypeNode;
    }) => typescript.ParenthesizedTypeNode;
    typeRecordNode: (keys: (any | typescript.TypeNode)[], values: (any | typescript.TypeNode)[], isNullable?: boolean, useLegacyResolution?: boolean) => typescript.TypeNode;
    typeReferenceNode: ({ typeArguments, typeName, }: {
        typeArguments?: typescript.TypeNode[];
        typeName: string | typescript.EntityName;
    }) => typescript.TypeReferenceNode;
    typeTupleNode: ({ isNullable, types, }: {
        isNullable?: boolean;
        types: Array<any | typescript.TypeNode>;
    }) => typescript.TypeNode;
    typeUnionNode: ({ isNullable, types, }: {
        isNullable?: boolean;
        types: ReadonlyArray<any | typescript.TypeNode>;
    }) => typescript.TypeNode;
    valueToExpression: <T = unknown>({ identifiers, isValueAccess, shorthand, unescape, value, }: {
        identifiers?: string[];
        isValueAccess?: boolean;
        shorthand?: boolean;
        unescape?: boolean;
        value: T;
    }) => typescript.Expression | undefined;
};

declare const utils: {
    stringCase: ({ case: _case, stripLeadingSeparators, value, }: {
        readonly case: StringCase | undefined;
        stripLeadingSeparators?: boolean;
        value: string;
    }) => string;
};

type Configs = UserConfig | (() => UserConfig) | (() => Promise<UserConfig>);
/**
 * Generate a client from the provided configuration.
 *
 * @param userConfig User provided {@link UserConfig} configuration.
 */
declare const createClient: (userConfig?: Configs) => Promise<ReadonlyArray<Client | IR.Context>>;
/**
 * Type helper for openapi-ts.config.ts, returns {@link UserConfig} object
 */
declare const defineConfig: (config: Configs) => Promise<UserConfig>;

export { IR, Plugin, UserConfig, clientDefaultConfig, clientDefaultMeta, clientPluginHandler, compiler, createClient, defaultPaginationKeywords, defaultPlugins, defineConfig, definePluginConfig, tsc, utils };
